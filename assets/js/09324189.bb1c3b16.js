"use strict";(self.webpackChunkarchetype_docs=self.webpackChunkarchetype_docs||[]).push([[6907],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),l=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(o.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(n),u=r,k=d["".concat(o,".").concat(u)]||d[u]||m[u]||i;return n?a.createElement(k,p(p({ref:t},c),{},{components:n})):a.createElement(k,p({ref:t},c))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,p=new Array(i);p[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[d]="string"==typeof e?e:r,p[1]=s;for(var l=2;l<i;l++)p[l]=n[l];return a.createElement.apply(null,p)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3372:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>p,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:3},p="Control",s={unversionedId:"reference/instructions/control",id:"reference/instructions/control",title:"Control",description:"if",source:"@site/docs/reference/instructions/control.md",sourceDirName:"reference/instructions",slug:"/reference/instructions/control",permalink:"/docs/reference/instructions/control",draft:!1,editUrl:"https://github.com/completium/archetype-docs/blob/main/docs/reference/instructions/control.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docs",previous:{title:"Assignment",permalink:"/docs/reference/instructions/assignment"},next:{title:"Divergent",permalink:"/docs/reference/instructions/divergent"}},o={},l=[{value:"<code>if</code>",id:"if",level:2},{value:"<code>match with</code>",id:"match-with",level:2},{value:"Option",id:"option",level:3},{value:"Or",id:"or",level:3},{value:"List",id:"list",level:3},{value:"States",id:"states",level:3},{value:"Enumeration",id:"enumeration",level:3},{value:"<code>for</code>",id:"for",level:2},{value:"Set",id:"set",level:3},{value:"List",id:"list-1",level:3},{value:"Map",id:"map",level:3},{value:"Asset",id:"asset",level:3},{value:"<code>while</code>",id:"while",level:2},{value:"<code>iter</code>",id:"iter",level:2}],c={toc:l};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"control"},"Control"),(0,r.kt)("h2",{id:"if"},(0,r.kt)("inlineCode",{parentName:"h2"},"if")),(0,r.kt)("p",null,"The conditional branching instruction ",(0,r.kt)("inlineCode",{parentName:"p"},"if e then i")," executes instruction ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," if the ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#bool"},"bool")," expression ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("p",null,"For example, ",(0,r.kt)("em",{parentName:"p"},"instr1")," is executed if ",(0,r.kt)("em",{parentName:"p"},"expr1")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"if expr1 then\n  instr1\n")),(0,r.kt)("p",null,"The instruction to execute when expression ",(0,r.kt)("em",{parentName:"p"},"expr1")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," follows the ",(0,r.kt)("inlineCode",{parentName:"p"},"else")," keyword:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"if expr1 then\n  instr1\nelse\n  instr2\n")),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/instructions/sequence"},"sequence")," of instructions is delimited by ",(0,r.kt)("inlineCode",{parentName:"p"},"begin ... end")," and  instructions are separated by ",(0,r.kt)("inlineCode",{parentName:"p"},";"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"if expr1 then begin\n  instr1;\n  instr2\nend else begin\n  instr3;\n  instr4\nend\n")),(0,r.kt)("p",null,"A dangling ",(0,r.kt)("inlineCode",{parentName:"p"},"else")," is attached to the ",(0,r.kt)("em",{parentName:"p"},"last")," ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),". For example in the following expression, the ",(0,r.kt)("inlineCode",{parentName:"p"},"else")," branch is attached to ",(0,r.kt)("inlineCode",{parentName:"p"},"if b = 1 then a := 42")," instruction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"if a = 1 then\n  if b = 1 then\n    a := 42\nelse\n  b := 42\n")),(0,r.kt)("p",null,"That is that it is equivalent to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"/* 'begin end' is optional here, it is to emphasis the logical structure */\nif a = 1 then begin\n  if b = 1 then\n    a := 42\n  else\n    b := 42\nend\n")),(0,r.kt)("p",null,"Note that there is no need for parenthesis in the bool expression; for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"var max : nat = 0;\nif a < b then\n  max := b\nelse\n  max := a\n")),(0,r.kt)("p",null,"A conditional ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/expressions/controls#if"},(0,r.kt)("inlineCode",{parentName:"a"},"if"))," ",(0,r.kt)("em",{parentName:"p"},"expression")," is also available."),(0,r.kt)("h2",{id:"match-with"},(0,r.kt)("inlineCode",{parentName:"h2"},"match with")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"match with")," instruction, inspired by the ",(0,r.kt)("a",{parentName:"p",href:"https://ocaml.org/"},"Ocaml")," language, desconstructs a value of ",(0,r.kt)("em",{parentName:"p"},"enumerated")," type to extract data from it. Enumerated types are ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#option%3CT%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"option")),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#or%3CT1,%20T2%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"or")),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#list%3CT%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"list")),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/declarations/compositetypes#states"},(0,r.kt)("inlineCode",{parentName:"a"},"states"))," and composite type ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#enum"},(0,r.kt)("inlineCode",{parentName:"a"},"enum")),"."),(0,r.kt)("p",null,"Its generic syntactic structure is presented below, given that ",(0,r.kt)("em",{parentName:"p"},"E1")," ... ",(0,r.kt)("em",{parentName:"p"},"En")," are the named values of the enumerated type of ",(0,r.kt)("em",{parentName:"p"},"expr1"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"match expr1 with\n| E1 -> instr1 /* instruction when expr1 is E1 */\n| E2 -> instr2 /* instruction when expr1 is E2 */\n/* ... */\n| En -> instrn /* instruction when expr1 is En */\nend\n")),(0,r.kt)("p",null,"If one named type ",(0,r.kt)("em",{parentName:"p"},"Ei")," is missing, the compiler fails with the message:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Partial match (missing "Ei")\n')),(0,r.kt)("p",null,"It is possible to escape the enumeration with the ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," keyword; for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"match expr1 with\n| E1 -> instr1\n| E2 -> instr2\n| _  -> instr3  /* instruction when expr1 is E3 or E4 ... or En */\nend\n")),(0,r.kt)("h3",{id:"option"},"Option"),(0,r.kt)("p",null,"An ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#option%3CT%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"option"))," value has two named values: ",(0,r.kt)("inlineCode",{parentName:"p"},"some")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"none"),"."),(0,r.kt)("p",null,"For example, suppose ",(0,r.kt)("inlineCode",{parentName:"p"},"opt")," is typed ",(0,r.kt)("inlineCode",{parentName:"p"},"option<string>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"match opt with\n| some(s) -> instr1 /* declares constant 's' typed 'string' in instr1 */\n| none    -> instr2\nend\n")),(0,r.kt)("h3",{id:"or"},"Or"),(0,r.kt)("p",null,"An ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#or%3CT1,%20T2%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"or"))," value has two named values: ",(0,r.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"right"),"."),(0,r.kt)("p",null,"For example, suppose ",(0,r.kt)("inlineCode",{parentName:"p"},"o")," is typed ",(0,r.kt)("inlineCode",{parentName:"p"},"or<string, nat>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"match o with\n| left(s)  -> instr1 /* declares constant 's' typed 'string' in instr1 */\n| right(n) -> instr2 /* declares constant 'n' typed 'nat' in instr2    */\nend\n")),(0,r.kt)("h3",{id:"list"},"List"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#list%3CT%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"list"))," value has two named values: ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," for empty list and ",(0,r.kt)("inlineCode",{parentName:"p"},"::")," for recursive composition."),(0,r.kt)("p",null,"For example, suppose ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," is typed ",(0,r.kt)("inlineCode",{parentName:"p"},"list<bytes>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"match l with\n| h::tl -> instr1 /* declares constants h typed 'bytes' and tl typed 'list<bytes' */\n| []    -> instr2 /* when l is empty */\nend\n")),(0,r.kt)("p",null,"In the example above, ",(0,r.kt)("inlineCode",{parentName:"p"},"h")," is the first element of the list ",(0,r.kt)("inlineCode",{parentName:"p"},"l"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"tl")," is the list ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," without the first element."),(0,r.kt)("p",null,"Note that Archetype does not support recursive calls, hence the ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," instruction cannot be used to fold a list as in Ocaml; it is rather used to retrieve the first element of a list and manage the case of an empty list. The ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/instructions/control#for"},(0,r.kt)("inlineCode",{parentName:"a"},"for"))," instruction is used to iterate over list elements."),(0,r.kt)("h3",{id:"states"},"States"),(0,r.kt)("p",null,"Contract's ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/declarations/compositetypes#states"},(0,r.kt)("inlineCode",{parentName:"a"},"states"))," may be interrogated with the ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," instruction."),(0,r.kt)("p",null,"Consider the states declaration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"states =\n| Pending initial\n| Shipped\n| Accepted\n| Canceled\n")),(0,r.kt)("p",null,"The following enables acting based on contract's state:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"match state with\n| Pending  -> instr1 /* when in Pending  state */\n| Shipped  -> instr2 /* when in Shipped  state */\n| Accepted -> instr3 /* when in Accepted state */\n| Canceled -> instr4 /* when in Canceled state */\nend;\n")),(0,r.kt)("h3",{id:"enumeration"},"Enumeration"),(0,r.kt)("p",null,"An ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#enum"},(0,r.kt)("inlineCode",{parentName:"a"},"enum"))," value has a user-defined list of values."),(0,r.kt)("p",null,"Consider the following declaration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"enum color =\n| RGB<nat * nat * nat>\n| Hex<bytes>\n| Css<string>\n")),(0,r.kt)("p",null,"The following enables acting based on ",(0,r.kt)("inlineCode",{parentName:"p"},"color"),"'s values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"match color with\n| RGB(rgb) -> instr1 /* declares 'rgb' as a tuple of 3 values typed 'nat' in instr1 */\n| Hex(h)   -> instr2 /* declares 'h' as a bytes value in instr2                     */\n| Css(css) -> instr3 /* declares 'css' as a string value in instr3                  */\nend\n")),(0,r.kt)("h2",{id:"for"},(0,r.kt)("inlineCode",{parentName:"h2"},"for")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," instruction iterates the elements of a ",(0,r.kt)("em",{parentName:"p"},"container")," (",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#set%3CT%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"set")),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#list%3CT%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"list")),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#map%3CK,%20V%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"map"))," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/asset"},(0,r.kt)("inlineCode",{parentName:"a"},"asset")),")."),(0,r.kt)("p",null,"The generic syntax structure is presented below, given ",(0,r.kt)("inlineCode",{parentName:"p"},"c")," is a container:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"for e in c do\n  instr1      /* declares constant element 'e' in instr1 */\ndone\n")),(0,r.kt)("p",null,"The type of element ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," above depends on the type of the container. See below for more information."),(0,r.kt)("p",null,"Note that it is ",(0,r.kt)("em",{parentName:"p"},"not")," possible to break an iteration. See the ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/expressions/builtins#fold%20(i%20:%20or%3CL,%20R%3E,%20id%20-%3E%20(body(id%20:%20L)%20:%20or%3CL,%20R%3E))"},(0,r.kt)("inlineCode",{parentName:"a"},"fold"))," builtin for an iteration process with a possiblity to break."),(0,r.kt)("h3",{id:"set"},"Set"),(0,r.kt)("p",null,"Elements of a ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#set%3CT%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"set"))," are iterated in the element's type natural order."),(0,r.kt)("p",null,"For example, suppose set ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," is typed ",(0,r.kt)("inlineCode",{parentName:"p"},"set<string>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"for e in s do\n  instr1 /* constant e is typed 'string' and is an element of s */\ndone\n")),(0,r.kt)("h3",{id:"list-1"},"List"),(0,r.kt)("p",null,"Elements of a ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#list%3CT%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"list"))," are iterated in the order of the list's construction process. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/instructions/containers#lprepende"},(0,r.kt)("inlineCode",{parentName:"a"},"prepend"))," and ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/instructions/containers#lconcatl"},(0,r.kt)("inlineCode",{parentName:"a"},"concat"))," instructions."),(0,r.kt)("p",null,"For example, suppose list ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," is typed ",(0,r.kt)("inlineCode",{parentName:"p"},"list<nat>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"for e in l do\n  instr1 /* constant 'e' is typed `nat` */\ndone\n")),(0,r.kt)("h3",{id:"map"},"Map"),(0,r.kt)("p",null,"Elements of a ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#map%3CK,%20V%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"map"))," ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#big_map%3CK,%20V%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"big_map"))," or ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#iterable_big_map%3CK,%20V%3E"},(0,r.kt)("inlineCode",{parentName:"a"},"iterable_big_map"))," are iterated in the natural order of the key."),(0,r.kt)("p",null,"For example, suppose map ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," is typed ",(0,r.kt)("inlineCode",{parentName:"p"},"map<string, bytes>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"for (k, v) in m do\n  instr1\nend\n")),(0,r.kt)("p",null,"In the example above:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"k")," is a key of the map typed ",(0,r.kt)("inlineCode",{parentName:"li"},"string")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v")," is the associated value typed ",(0,r.kt)("inlineCode",{parentName:"li"},"bytes"))),(0,r.kt)("h3",{id:"asset"},"Asset"),(0,r.kt)("p",null,"Elements of a ",(0,r.kt)("a",{parentName:"p",href:"/docs/asset"},(0,r.kt)("inlineCode",{parentName:"a"},"asset"))," are iterated in the natural order of the asset identifier."),(0,r.kt)("p",null,"Consider the following ",(0,r.kt)("inlineCode",{parentName:"p"},"visitor")," asset declaration identified by ",(0,r.kt)("inlineCode",{parentName:"p"},"login")," field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"asset visitor identified by login {\n  login    : address;\n  fullname : string;\n  nbvisits : nat = 0\n}\n")),(0,r.kt)("p",null,"The following iterates on the ",(0,r.kt)("inlineCode",{parentName:"p"},"visitor")," asset collection:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"for log in visitor do\n  instr1 /* 'log' is the visitor 'login' typed 'address' */\ndone\n")),(0,r.kt)("p",null,"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"log")," is the iterated visitor's login, visitor data is accessed with ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/expressions/asset#ak--asset_keyaf"},(0,r.kt)("inlineCode",{parentName:"a"},"[]"))," operator, like for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"var nbv = visitor[log].nbvisits\n")),(0,r.kt)("h2",{id:"while"},(0,r.kt)("inlineCode",{parentName:"h2"},"while")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"while")," instruction executes an instruction as long as a condition holds true."),(0,r.kt)("p",null,"The generic syntax is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"while expr1 do\n  instr1\ndone\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"expr1")," is a ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#bool"},(0,r.kt)("inlineCode",{parentName:"a"},"bool"))," typed expression."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"var i = 0;\nwhile i < 20 do\n  instr1;\n  i += 1\ndone\n")),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"There is no guarantee that the iteration terminates. In such a case the entrypoint fails with a ",(0,r.kt)("inlineCode",{parentName:"p"},"gas exceeded")," error.")),(0,r.kt)("h2",{id:"iter"},(0,r.kt)("inlineCode",{parentName:"h2"},"iter")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"iter")," instruction iterates over a integer value in a specified range. The generic syntax is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"iter i from expr1 to expr2 do\n  instr1 /* declares an integer constant 'i' between expr1 and expr2 included */\ndone\n")),(0,r.kt)("p",null,"In the instruction above, ",(0,r.kt)("em",{parentName:"p"},"expr1")," and ",(0,r.kt)("em",{parentName:"p"},"expr2")," are expressions typed ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/types#nat"},(0,r.kt)("inlineCode",{parentName:"a"},"int")),". It does not iterate if ",(0,r.kt)("em",{parentName:"p"},"expr1")," is greater than ",(0,r.kt)("em",{parentName:"p"},"expr2"),"."),(0,r.kt)("p",null,"The initial ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," value may be omitted, it is then defaulted to ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-archetype"},"iter i to expr2 do\n  instr1 /* declares an integer constant 'i' between 1 and expr2 included */\ndone\n")))}d.isMDXComponent=!0}}]);